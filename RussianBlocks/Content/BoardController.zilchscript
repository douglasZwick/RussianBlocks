class BoardController : ZilchComponent
{
  sends Gravity : GravityEvent;
  
  
  [Property]
  var GravityMagnitude : Real = 1;
  [Property]
  var GravityDirection : Real3 = -Real3.YAxis;
  [Property]
  var GridOriginPath : CogPath = CogPath("GridOrigin");
  
  var NewPieceSpawnPosition : Real3 = Real3(0, 10, 0);
  var PieceArchetype : Archetype = Archetype.Piece;
  var PieceArchetypes : Array[Archetype] = Array[Archetype]()
  {
    Archetype.IPiece,
    Archetype.OPiece,
    Archetype.TPiece,
    Archetype.LPiece,
    Archetype.JPiece,
    Archetype.SPiece,
    Archetype.ZPiece,
  };
  var StaticSquareArchetype : Archetype = Archetype.StaticSquare;
  var LineIdentificationSquareArchetype : Archetype = Archetype.LineIdentificationSquare;
  
  var GridSize : Integer2 = Integer2(10, 20);
  var Grid : Array[Array[SquareData]];
  var GridOrigin : Real3;
  
  var IndexQueue : Array[Integer] = Array[Integer]();
  var RNG : Random = Random();
  
  var LineCount : Integer = 0;
  
  
  function Initialize(init : CogInitializer)
  {
    this.GridOrigin = this.GridOriginPath.Transform.WorldTranslation;
    
    this.Grid = Array[Array[SquareData]]();
    
    for (var i = 0; i < this.GridSize.X; ++i)
    {
      var column = Array[SquareData]();
      
      for (var j = 0; j < this.GridSize.Y; ++j)
      {
        column.Add(SquareData());
      }
      
      this.Grid.Add(column);
    }
    
    this.AddBagToQueue();
    this.AddBagToQueue();
    
    Console.WriteLine(this.QueueToString());
    
    Zero.Connect(init, Events.AllObjectsInitialized, this.OnAllObjectsInitialized);
    Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    Zero.Connect(this.Space, Events.PieceStuck, this.OnPieceStuck);
  }
  
  
  function OnAllObjectsInitialized(event : CogInitializerEvent)
  {
    this.CreateNewPiece();
  }
  
  
  function OnLogicUpdate(event : UpdateEvent)
  {
    var ge = GravityEvent();
    ge.Magnitude = this.GravityMagnitude;
    ge.Direction = this.GravityDirection;
    ge.Dt = event.Dt;
    this.Space.DispatchEvent(Events.Gravity, ge);
  }
  
  
  function OnPieceStuck(event : PieceEvent)
  {
    this.CreateStaticBlocks(event);
    this.DestroyOldPiece(event);
    this.CheckForSquares();
    this.CheckForLines();
    this.CheckForSquares();
    this.CreateNewPiece();
  }
  
  
  function CreateStaticBlocks(event : PieceEvent)
  {
    var colliderTransform = event.Piece.ColliderTransform;
    var angle = colliderTransform.EulerAngles.Z;
    
    foreach (var child in colliderTransform.Owner.Children)
    {
      var childTransform = child.Transform;
      var position = childTransform.WorldTranslation;
      var data = this.RotateData(child.Atom.Data, angle);
      
      var staticSquare = this.Space.CreateAtPosition(this.StaticSquareArchetype, position);
      staticSquare.Sprite.VertexColor = PieceController.Colors[data.Type];
      
      data.StaticSquare = staticSquare;
      var index = this.WorldPositionToGridIndex(position);
      this.Grid[index.X][index.Y] = data;
    }
  }
  
  
  function DestroyOldPiece(event : PieceEvent)
  {
    event.Piece.Owner.Destroy();
  }
  
  
  function CheckForSquares()
  {
    
  }
  
  
  function CheckForLines()
  {
    var linesCleared = 0;
    
    for (var y = 0; y < this.GridSize.Y; ++y)
    {
      var filledSquares = Array[Integer2]();
      
      for (var x = 0; x < this.GridSize.X; ++x)
      {
        var data = this.Grid[x][y];
        
        if (data.Filled)
        {
          var index = Integer2(x, y);
          filledSquares.Add(index);
        }
      }
      
      if (filledSquares.Count >= this.GridSize.X)
      {
        ++linesCleared;
        
        foreach (var index in filledSquares)
        {
          this.Grid[index.X][index.Y].Filled = false;
          var square = this.Grid[index.X][index.Y].StaticSquare;
          if (square != null)
            square.Destroy();
        }
      }
    }
    
    this.LineCount += linesCleared;
    
    if (linesCleared > 0)
    {
      var clearString = "";
      
      if      (linesCleared == 1)
        clearString = "  Single    --   40 pts";
      else if (linesCleared == 2)
        clearString = "  Double!    -  100 pts";
      else if (linesCleared == 3)
        clearString = "  Triple!    -  300 pts";
      else if (linesCleared == 4)
        clearString = "YES! TETRIS! - 1200 pts";
      
      Console.WriteLine(clearString);
      Console.WriteLine("Total: `this.LineCount`");
    }
  }
  
  
  function AddBagToQueue()
  {
    var count = this.PieceArchetypes.Count;
    var bag = Array[Integer](count);
    for (var i = 0; i < count; ++i)
      bag[i] = i;
    this.ShuffleArray(bag);
    foreach (var index in bag)
      this.IndexQueue.Add(index);
  }
  
  
  function ShuffleArray(array : Array[Integer])
  {
    var n = array.Count;
    for (var i = n - 1; i > 0; --i)
    {
      var r = this.RNG.DieRoll(i + 1) - 1;
      this.SwapIndices(array, i, r);
    }
  }
  
  
  function SwapIndices(array : Array[Integer], a : Integer, b : Integer)
  {
    var temp = array[a];
    array[a] = array[b];
    array[b] = temp;
  }
  
  
  function QueueToString() : String
  {
    var output = StringBuilder();
    output.Write("{");
    
    foreach (var index in this.IndexQueue)
      output.Write(" `index as PieceType`");
    
    output.Write(" }");
    
    return output.ToString();
  }
  
  
  function CreateNewPiece()
  {
    var index = this.IndexQueue[0];
    this.IndexQueue.RemoveAt(0);
    var archetype = this.PieceArchetypes[index];
    var piece = this.Space.CreateAtPosition(archetype, this.NewPieceSpawnPosition);
    
    if (this.IndexQueue.Count < this.PieceArchetypes.Count)
      this.AddBagToQueue();
  }
  
  
  function GridIndexToWorldPosition(index : Integer2) : Real3
  {
    return this.GridOrigin + Real3(index.X, index.Y, 0);
  }
  
  
  function WorldPositionToGridIndex(position : Real3) : Integer2
  {
    var shifted = Math.Round(position - this.GridOrigin);
    return Integer2(shifted.X as Integer, shifted.Y as Integer);
  }
  
  
  function RotateData(data : SquareData, angle : Real) : SquareData
  {
    var output = SquareData();
    output.Filled = data.Filled;
    output.Type = data.Type;
    var eighth = Math.Pi / 4;
    
    if      (-eighth <= angle && angle < eighth)          // right quadrant
    {
      output.RtConnection = data.RtConnection;
      output.UpConnection = data.UpConnection;
      output.LtConnection = data.LtConnection;
      output.DnConnection = data.DnConnection;
    }
    else if (eighth <= angle && angle < 3 * eighth)       // top quadrant
    {
      output.UpConnection = data.RtConnection;
      output.LtConnection = data.UpConnection;
      output.DnConnection = data.LtConnection;
      output.RtConnection = data.DnConnection;
    }
    else if (3 * eighth <= angle || angle < -3 * eighth)  // left quadrant
    {
      output.LtConnection = data.RtConnection;
      output.DnConnection = data.UpConnection;
      output.RtConnection = data.LtConnection;
      output.UpConnection = data.DnConnection;
    }
    else //  -3 * eighth <= angle && angle < -eighth      // bottom quadrant
    {
      output.DnConnection = data.RtConnection;
      output.RtConnection = data.UpConnection;
      output.UpConnection = data.LtConnection;
      output.LtConnection = data.DnConnection;
    }
    
    return output;
  }
}


class GravityEvent : ZilchEvent
{
  var Magnitude : Real;
  var Direction : Real3;
  var Dt : Real;
}


class SquareData : ZilchObject
{
  [Property] var Filled : Boolean = false;
  [Property] var RtConnection : Boolean = false;
  [Property] var LtConnection : Boolean = false;
  [Property] var UpConnection : Boolean = false;
  [Property] var DnConnection : Boolean = false;
  [Property] var Type : PieceType;
  var StaticSquare : Cog = null;
  
  
  function Copy() : SquareData
  {
    var output = SquareData();
    output.Filled = this.Filled;
    output.RtConnection = this.RtConnection;
    output.LtConnection = this.LtConnection;
    output.UpConnection = this.UpConnection;
    output.DnConnection = this.DnConnection;
    
    return output;
  }
  
  
  function ToString() : String
  {
    var format = "F: %d | RULD: %d%d%d%d | Type: %s | Cog: %s";
    var filled = this.Filled as Integer;
    var rt = this.RtConnection as Integer;
    var up = this.UpConnection as Integer;
    var lt = this.LtConnection as Integer;
    var dn = this.DnConnection as Integer;
    return String.FormatC(format, filled, rt, up, lt, dn, this.Type, this.StaticSquare);
  }
}
